import "./chunk-ROME4SDB.js";

// node_modules/image-compressor.js/dist/image-compressor.esm.js
function createCommonjsModule(fn, module) {
  return module = { exports: {} }, fn(module, module.exports), module.exports;
}
var canvasToBlob = createCommonjsModule(function(module) {
  (function(window2) {
    var CanvasPrototype = window2.HTMLCanvasElement && window2.HTMLCanvasElement.prototype;
    var hasBlobConstructor = window2.Blob && function() {
      try {
        return Boolean(new Blob());
      } catch (e) {
        return false;
      }
    }();
    var hasArrayBufferViewSupport = hasBlobConstructor && window2.Uint8Array && function() {
      try {
        return new Blob([new Uint8Array(100)]).size === 100;
      } catch (e) {
        return false;
      }
    }();
    var BlobBuilder = window2.BlobBuilder || window2.WebKitBlobBuilder || window2.MozBlobBuilder || window2.MSBlobBuilder;
    var dataURIPattern = /^data:((.*?)(;charset=.*?)?)(;base64)?,/;
    var dataURLtoBlob = (hasBlobConstructor || BlobBuilder) && window2.atob && window2.ArrayBuffer && window2.Uint8Array && function(dataURI) {
      var matches, mediaType, isBase64, dataString, byteString, arrayBuffer, intArray, i, bb;
      matches = dataURI.match(dataURIPattern);
      if (!matches) {
        throw new Error("invalid data URI");
      }
      mediaType = matches[2] ? matches[1] : "text/plain" + (matches[3] || ";charset=US-ASCII");
      isBase64 = !!matches[4];
      dataString = dataURI.slice(matches[0].length);
      if (isBase64) {
        byteString = atob(dataString);
      } else {
        byteString = decodeURIComponent(dataString);
      }
      arrayBuffer = new ArrayBuffer(byteString.length);
      intArray = new Uint8Array(arrayBuffer);
      for (i = 0; i < byteString.length; i += 1) {
        intArray[i] = byteString.charCodeAt(i);
      }
      if (hasBlobConstructor) {
        return new Blob([hasArrayBufferViewSupport ? intArray : arrayBuffer], {
          type: mediaType
        });
      }
      bb = new BlobBuilder();
      bb.append(arrayBuffer);
      return bb.getBlob(mediaType);
    };
    if (window2.HTMLCanvasElement && !CanvasPrototype.toBlob) {
      if (CanvasPrototype.mozGetAsFile) {
        CanvasPrototype.toBlob = function(callback, type, quality) {
          var self = this;
          setTimeout(function() {
            if (quality && CanvasPrototype.toDataURL && dataURLtoBlob) {
              callback(dataURLtoBlob(self.toDataURL(type, quality)));
            } else {
              callback(self.mozGetAsFile("blob", type));
            }
          });
        };
      } else if (CanvasPrototype.toDataURL && dataURLtoBlob) {
        CanvasPrototype.toBlob = function(callback, type, quality) {
          var self = this;
          setTimeout(function() {
            callback(dataURLtoBlob(self.toDataURL(type, quality)));
          });
        };
      }
    }
    if (false) {
      (void 0)(function() {
        return dataURLtoBlob;
      });
    } else if (module.exports) {
      module.exports = dataURLtoBlob;
    } else {
      window2.dataURLtoBlob = dataURLtoBlob;
    }
  })(window);
});
var toString = Object.prototype.toString;
var isBlob = function(x) {
  return x instanceof Blob || toString.call(x) === "[object Blob]";
};
var DEFAULTS = {
  /**
   * Indicates if read the image's Exif Orientation information,
   * and then rotate or flip the image automatically.
   * @type {boolean}
   */
  checkOrientation: true,
  /**
   * The max width of the output image.
   * @type {number}
   */
  maxWidth: Infinity,
  /**
   * The max height of the output image.
   * @type {number}
   */
  maxHeight: Infinity,
  /**
   * The min width of the output image.
   * @type {number}
   */
  minWidth: 0,
  /**
   * The min height of the output image.
   * @type {number}
   */
  minHeight: 0,
  /**
   * The width of the output image.
   * If not specified, the natural width of the source image will be used.
   * @type {number}
   */
  width: void 0,
  /**
   * The height of the output image.
   * If not specified, the natural height of the source image will be used.
   * @type {number}
   */
  height: void 0,
  /**
   * The quality of the output image.
   * It must be a number between `0` and `1`,
   * and only available for `image/jpeg` and `image/webp` images.
   * Check out {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob canvas.toBlob}.
   * @type {number}
   */
  quality: 0.8,
  /**
   * The mime type of the output image.
   * By default, the original mime type of the source image file will be used.
   * @type {string}
   */
  mimeType: "auto",
  /**
   * PNG files over this value (5M by default) will be converted to JPEGs.
   * To disable this, just set the value to `Infinity`.
   * Check out {@link https://github.com/xkeshi/image-compressor/issues/2 #2}.
   * @type {number}
   */
  convertSize: 5e6,
  /**
   * The hook function to execute before draw the image into the canvas for compression.
   * @type {Function}
   * @param {CanvasRenderingContext2D} context - The 2d rendering context of the canvas.
   * @param {HTMLCanvasElement} canvas - The canvas for compression.
   * @example
   * function (context, canvas) { context.fillStyle = '#fff' }
   */
  beforeDraw: null,
  /**
   * The hook function to execute after drew the image into the canvas for compression.
   * @type {Function}
   * @param {CanvasRenderingContext2D} context - The 2d rendering context of the canvas.
   * @param {HTMLCanvasElement} canvas - The canvas for compression.
   * @example
   * function (context, canvas) { context.filter = grayscale(100%) }
   */
  drew: null,
  /**
   * The hook function to execute when success to compress the image.
   * @type {Function}
   * @param {File} file - The compressed image File object.
   * @example
   * function (file) { console.log(file) }
   */
  success: null,
  /**
   * The hook function to execute when fail to compress the image.
   * @type {Function}
   * @param {Error} err - An Error object.
   * @example
   * function (err) { console.log(err.message) }
   */
  error: null
};
var REGEXP_IMAGE_TYPE = /^image\/.+$/;
function isImageType(value) {
  return REGEXP_IMAGE_TYPE.test(value);
}
function imageTypeToExtension(value) {
  var includeDot = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
  var extension = isImageType(value) ? value.substr(6) : "";
  if (extension === "jpeg") {
    extension = "jpg";
  }
  if (extension && includeDot) {
    extension = "." + extension;
  }
  return extension;
}
var fromCharCode = String.fromCharCode;
function getStringFromCharCode(dataView, start, length) {
  var str = "";
  var i = void 0;
  length += start;
  for (i = start; i < length; i += 1) {
    str += fromCharCode(dataView.getUint8(i));
  }
  return str;
}
var _window = window;
var btoa = _window.btoa;
function arrayBufferToDataURL(arrayBuffer, mimeType) {
  var uint8 = new Uint8Array(arrayBuffer);
  var data = "";
  if (typeof uint8.forEach === "function") {
    uint8.forEach(function(value) {
      data += fromCharCode(value);
    });
  } else {
    var length = uint8.length;
    for (var i = 0; i < length; i += 1) {
      data += fromCharCode(uint8[i]);
    }
  }
  return "data:" + mimeType + ";base64," + btoa(data);
}
function getOrientation(arrayBuffer) {
  var dataView = new DataView(arrayBuffer);
  var orientation = void 0;
  var littleEndian = void 0;
  var app1Start = void 0;
  var ifdStart = void 0;
  if (dataView.getUint8(0) === 255 && dataView.getUint8(1) === 216) {
    var length = dataView.byteLength;
    var offset = 2;
    while (offset < length) {
      if (dataView.getUint8(offset) === 255 && dataView.getUint8(offset + 1) === 225) {
        app1Start = offset;
        break;
      }
      offset += 1;
    }
  }
  if (app1Start) {
    var exifIDCode = app1Start + 4;
    var tiffOffset = app1Start + 10;
    if (getStringFromCharCode(dataView, exifIDCode, 4) === "Exif") {
      var endianness = dataView.getUint16(tiffOffset);
      littleEndian = endianness === 18761;
      if (littleEndian || endianness === 19789) {
        if (dataView.getUint16(tiffOffset + 2, littleEndian) === 42) {
          var firstIFDOffset = dataView.getUint32(tiffOffset + 4, littleEndian);
          if (firstIFDOffset >= 8) {
            ifdStart = tiffOffset + firstIFDOffset;
          }
        }
      }
    }
  }
  if (ifdStart) {
    var _length = dataView.getUint16(ifdStart, littleEndian);
    var _offset = void 0;
    var i = void 0;
    for (i = 0; i < _length; i += 1) {
      _offset = ifdStart + i * 12 + 2;
      if (dataView.getUint16(_offset, littleEndian) === 274) {
        _offset += 8;
        orientation = dataView.getUint16(_offset, littleEndian);
        dataView.setUint16(_offset, 1, littleEndian);
        break;
      }
    }
  }
  return orientation;
}
function parseOrientation(orientation) {
  var rotate = 0;
  var scaleX = 1;
  var scaleY = 1;
  switch (orientation) {
    case 2:
      scaleX = -1;
      break;
    case 3:
      rotate = -180;
      break;
    case 4:
      scaleY = -1;
      break;
    case 5:
      rotate = 90;
      scaleY = -1;
      break;
    case 6:
      rotate = 90;
      break;
    case 7:
      rotate = 90;
      scaleX = -1;
      break;
    case 8:
      rotate = -90;
      break;
    default:
  }
  return {
    rotate,
    scaleX,
    scaleY
  };
}
var REGEXP_DECIMALS = /\.\d*(?:0|9){12}\d*$/i;
function normalizeDecimalNumber(value) {
  var times = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1e11;
  return REGEXP_DECIMALS.test(value) ? Math.round(value * times) / times : value;
}
var classCallCheck = function(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};
var createClass = function() {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  return function(Constructor, protoProps, staticProps) {
    if (protoProps)
      defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();
var _extends = Object.assign || function(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];
    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }
  return target;
};
var _window$1 = window;
var ArrayBuffer$1 = _window$1.ArrayBuffer;
var FileReader = _window$1.FileReader;
var URL = window.URL || window.webkitURL;
var REGEXP_EXTENSION = /\.\w+$/;
var ImageCompressor = function() {
  function ImageCompressor2(file, options) {
    classCallCheck(this, ImageCompressor2);
    this.result = null;
    if (file) {
      this.compress(file, options);
    }
  }
  createClass(ImageCompressor2, [{
    key: "compress",
    value: function compress(file, options) {
      var _this = this;
      var image = new Image();
      options = _extends({}, DEFAULTS, options);
      if (!ArrayBuffer$1) {
        options.checkOrientation = false;
      }
      return new Promise(function(resolve, reject) {
        if (!isBlob(file)) {
          reject(new Error("The first argument must be a File or Blob object."));
          return;
        }
        var mimeType = file.type;
        if (!isImageType(mimeType)) {
          reject(new Error("The first argument must be an image File or Blob object."));
          return;
        }
        if (!URL && !FileReader) {
          reject(new Error("The current browser does not support image compression."));
          return;
        }
        if (URL && !options.checkOrientation) {
          resolve({
            url: URL.createObjectURL(file)
          });
        } else if (FileReader) {
          var reader = new FileReader();
          var checkOrientation = options.checkOrientation && mimeType === "image/jpeg";
          reader.onload = function(_ref) {
            var target = _ref.target;
            var result = target.result;
            resolve(checkOrientation ? _extends({
              url: arrayBufferToDataURL(result, mimeType)
            }, parseOrientation(getOrientation(result))) : {
              url: result
            });
          };
          reader.onabort = function() {
            reject(new Error("Aborted to load the image with FileReader."));
          };
          reader.onerror = function() {
            reject(new Error("Failed to load the image with FileReader."));
          };
          if (checkOrientation) {
            reader.readAsArrayBuffer(file);
          } else {
            reader.readAsDataURL(file);
          }
        }
      }).then(function(data) {
        return new Promise(function(resolve, reject) {
          image.onload = function() {
            return resolve(_extends({}, data, {
              naturalWidth: image.naturalWidth,
              naturalHeight: image.naturalHeight
            }));
          };
          image.onabort = function() {
            reject(new Error("Aborted to load the image."));
          };
          image.onerror = function() {
            reject(new Error("Failed to load the image."));
          };
          image.alt = file.name;
          image.src = data.url;
        });
      }).then(function(_ref2) {
        var naturalWidth = _ref2.naturalWidth, naturalHeight = _ref2.naturalHeight, _ref2$rotate = _ref2.rotate, rotate = _ref2$rotate === void 0 ? 0 : _ref2$rotate, _ref2$scaleX = _ref2.scaleX, scaleX = _ref2$scaleX === void 0 ? 1 : _ref2$scaleX, _ref2$scaleY = _ref2.scaleY, scaleY = _ref2$scaleY === void 0 ? 1 : _ref2$scaleY;
        return new Promise(function(resolve) {
          var canvas = document.createElement("canvas");
          var context = canvas.getContext("2d");
          var aspectRatio = naturalWidth / naturalHeight;
          var maxWidth = Math.max(options.maxWidth, 0) || Infinity;
          var maxHeight = Math.max(options.maxHeight, 0) || Infinity;
          var minWidth = Math.max(options.minWidth, 0) || 0;
          var minHeight = Math.max(options.minHeight, 0) || 0;
          var width = naturalWidth;
          var height = naturalHeight;
          if (maxWidth < Infinity && maxHeight < Infinity) {
            if (maxHeight * aspectRatio > maxWidth) {
              maxHeight = maxWidth / aspectRatio;
            } else {
              maxWidth = maxHeight * aspectRatio;
            }
          } else if (maxWidth < Infinity) {
            maxHeight = maxWidth / aspectRatio;
          } else if (maxHeight < Infinity) {
            maxWidth = maxHeight * aspectRatio;
          }
          if (minWidth > 0 && minHeight > 0) {
            if (minHeight * aspectRatio > minWidth) {
              minHeight = minWidth / aspectRatio;
            } else {
              minWidth = minHeight * aspectRatio;
            }
          } else if (minWidth > 0) {
            minHeight = minWidth / aspectRatio;
          } else if (minHeight > 0) {
            minWidth = minHeight * aspectRatio;
          }
          if (options.width > 0) {
            var _options = options;
            width = _options.width;
            height = width / aspectRatio;
          } else if (options.height > 0) {
            var _options2 = options;
            height = _options2.height;
            width = height * aspectRatio;
          }
          width = Math.min(Math.max(width, minWidth), maxWidth);
          height = Math.min(Math.max(height, minHeight), maxHeight);
          var destX = -width / 2;
          var destY = -height / 2;
          var destWidth = width;
          var destHeight = height;
          if (Math.abs(rotate) % 180 === 90) {
            var _width$height = {
              width: height,
              height: width
            };
            width = _width$height.width;
            height = _width$height.height;
          }
          canvas.width = normalizeDecimalNumber(width);
          canvas.height = normalizeDecimalNumber(height);
          if (!isImageType(options.mimeType)) {
            options.mimeType = file.type;
          }
          var defaultFillStyle = "transparent";
          if (file.size > options.convertSize && options.mimeType === "image/png") {
            defaultFillStyle = "#fff";
            options.mimeType = "image/jpeg";
          }
          context.fillStyle = defaultFillStyle;
          context.fillRect(0, 0, width, height);
          context.save();
          context.translate(width / 2, height / 2);
          context.rotate(rotate * Math.PI / 180);
          context.scale(scaleX, scaleY);
          if (options.beforeDraw) {
            options.beforeDraw.call(_this, context, canvas);
          }
          context.drawImage(image, Math.floor(normalizeDecimalNumber(destX)), Math.floor(normalizeDecimalNumber(destY)), Math.floor(normalizeDecimalNumber(destWidth)), Math.floor(normalizeDecimalNumber(destHeight)));
          if (options.drew) {
            options.drew.call(_this, context, canvas);
          }
          context.restore();
          var done = function done2(result) {
            resolve({
              naturalWidth,
              naturalHeight,
              result
            });
          };
          if (canvas.toBlob) {
            canvas.toBlob(done, options.mimeType, options.quality);
          } else {
            done(canvasToBlob(canvas.toDataURL(options.mimeType, options.quality)));
          }
        });
      }).then(function(_ref3) {
        var naturalWidth = _ref3.naturalWidth, naturalHeight = _ref3.naturalHeight, result = _ref3.result;
        if (URL && !options.checkOrientation) {
          URL.revokeObjectURL(image.src);
        }
        if (result) {
          if (result.size > file.size && options.mimeType === file.type && !(options.width > naturalWidth || options.height > naturalHeight || options.minWidth > naturalWidth || options.minHeight > naturalHeight)) {
            result = file;
          } else {
            var date = /* @__PURE__ */ new Date();
            result.lastModified = date.getTime();
            result.lastModifiedDate = date;
            result.name = file.name;
            if (result.name && result.type !== file.type) {
              result.name = result.name.replace(REGEXP_EXTENSION, imageTypeToExtension(result.type));
            }
          }
        } else {
          result = file;
        }
        _this.result = result;
        if (options.success) {
          options.success.call(_this, result);
        }
        return Promise.resolve(result);
      }).catch(function(err) {
        if (!options.error) {
          throw err;
        }
        options.error.call(_this, err);
      });
    }
  }]);
  return ImageCompressor2;
}();
var image_compressor_esm_default = ImageCompressor;
export {
  image_compressor_esm_default as default
};
/*! Bundled license information:

image-compressor.js/dist/image-compressor.esm.js:
  (*!
   * Image Compressor v1.1.4
   * https://xkeshi.github.io/image-compressor
   *
   * Copyright 2017-present Chen Fengyuan
   * Released under the MIT license
   *
   * Date: 2018-06-20T07:28:41.051Z
   *)
*/
//# sourceMappingURL=image-compressor__js.js.map
